# ORB特征
ORB特征具有局部不变性的特点。ORB（Oriented FAST and Rotated BRIEF）,从名字可以看出它是对FAST特征点和BRIEF特征描述子的综合和改进。ORB是除了SIFT和SURF之外的一个很好的选择，它有很高的效率，最重要的是它时免费的，而SIFT和SURF都是有专利的，在商业软件中使用需要购买授权许可。

## FAST特征点检测
FAST（Features From Accelerated Segment Test）是Edward Rosten和Tom Drummond两位大神于2006年在《Machine learning for high-speed corner detection》中提出的特征点算法。只是确定特征点，不涉及特征点的特征描述。

FAST角点定义为：若某像素与其周围邻域内足够多的像素点相差较大，则该像素可能是角点。

FAST具体计算过程：

1. 从图片中选取一个像素点P，像素点的密度（灰度值）为Ip。

2. 定义一个阈值T（比如灰度差值20%）。
3. 以P为中心半径为3的环（Bresenham环）上的16个像素点与P的密度差值，如果有N个差值都大于阈值T，则P为一个特征点。
4. 为了提高计算速度，首先计算p1、p9与中心p的像素差，若它们绝对值都小于阈值，则p点不可能是特征点，直接pass掉；否则，当做候选点，有待进一步考察；
5. 若p是候选点，则继续计算p1、p9、p5、p13与中心p的像素差，若它们的绝对值有至少3个超过阈值，则当做候选点，再进行下一步考察；否则，直接pass掉；
6. 若p是候选点，则计算p1到p16这16个点与中心p的像素差，若它们有至少N个超过阈值，则是特征点；否则，直接pass掉。
7. 对图像进行非极大值抑制：计算出特征点的FAST得分值（即score值，也即s值），判断以特征点p为中心的一个邻域（如3×3或5×5）内，计算若有多个特征点，则判断每个特征点的s值（16个点与中心差值的绝对值总和），若p是邻域所有特征点中响应值最大的，则保留；否则，抑制。若邻域内只有一个特征点（角点），则保留。得分计算公式如下（公式中用V表示得分，t表示阈值）：

<a href="https://www.codecogs.com/eqnedit.php?latex=V=max\left\{\begin{matrix}\sum&space;(value-p),&space;value-p&space;>t&space;\\&space;\sum&space;(p-value),&space;value-p&space;<t\end{matrix}\right." target="_blank"><img src="https://latex.codecogs.com/gif.latex?V=max\left\{\begin{matrix}\sum&space;(value-p),&space;value-p&space;>t&space;\\&space;\sum&space;(p-value),&space;value-p&space;<t\end{matrix}\right." title="V=max\left\{\begin{matrix}\sum (value-p), value-p >t \\ \sum (p-value), value-p <t\end{matrix}\right." /></a>

1. 对所有的像素点进行上述计算来判断是否为特征点。

上面是FAST-9（N=9），当然FAST-10、FAST-11、FAST-12也是一样的.FAST算法实现起来简单，尤其是以速度快著称。

## BRIEF
BRIEF（Binary Robust Independent Elementary Features）特征描述符，它不提供提取特征点的方法，必须首先使用FAST、SIFT、SURF等提取特征点。SIFT特征采用了128维的特征描述子，由于描述子用的浮点数，所以它将会占用512 bytes的空间。类似地，对于SURF特征，常见的是64维的描述子，它也将占用256bytes的空间。如果一幅图像中有1000个特征点（不要惊讶，这是很正常的事），那么SIFT或SURF特征描述子将占用大量的内存空间，对于那些资源紧张的应用，尤其是嵌入式的应用，这样的特征描述子显然是不可行的。而且，越占有越大的空间，意味着越长的匹配时间。


实际上SFIT或SURF的特征描述子中，并不是所有维都在匹配中有着实质性的作用。我们可以用PCA、LDA等特征降维的方法来压缩特征描述子的维度。还有一些算法，例如LSH，将SIFT的特征描述子转换为一个二值的码串，然后这个码串用汉明距离进行特征点之间的匹配。这种方法将大大提高特征之间的匹配，因为汉明距离的计算可以用异或操作然后计算二进制位数来实现，在现代计算机结构中很方便。

算法步骤：
1、为减少噪声干扰，先对图像进行高斯滤波（方差为2，高斯窗口为9×9）。

2、以特征点为中心，取SxS的邻域大窗口。在大窗口中随机选取一对（两个）5×5的子窗口，比较子窗口内的像素和（可用积分图像完成），进行二进制赋值。（一般S=31）

其中，p(x)，p(y)分别随机点x=(u1,v1), y=(u2,v2)所在5×5子窗口的像素和。

3、在大窗口中随机选取N对子窗口，重复步骤2的二进制赋值，形成一个二进制编码，这个编码就是对特征点的描述，即特征描述子。（一般N=256）

构造一个512个bit的BRIEF，就需要512对[x,y]，且需要注意，它们是有序的，每次计算位置都相同，否则影响最终结果。也就说说，一旦选定了512对[x,y]，那么，无论是提取特征，还是匹配特征，都要按照这512对进行计算。512/8=64就是存储BRIEF所需的字节数，论文将512个bit的BRIEF又称作BRIEF-64。

在opencn2.4.9中，该区域的大小为48×48。再在该区域内，以某种特定的方式选择nd个像素点对。然后比较像素点对的灰度值：

I(pi)和I(qi)分别表示第i个像素点对的两个像素pi和qi的灰度值。最后把补丁区域内所有点对的比较结果串成一个二值位字符串的形式，从而形成了该特征点的描述符。

B = b0b1…bi…bnd （2）

通过实验对比可知，nd = 128，256和512时，在运算速度，空间占用和准确性上可以达到最佳的效果。如果用字节型来表示描述符的话，那么

k =nd / 8 （3）

k就表示为描述符的字节数。

以上便是BRIEF特征描述算法的步骤。

关于一对随机点的选择方法，原作者测试了以下5种方法，其中方法（2）比较好。



这5种方法生成的256对随机点如下（一条线段的两个端点是一对）：