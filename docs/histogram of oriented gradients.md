# 方向梯度直方图(HOG)
计算过程：

1. patch

HOG算法，从一个特定大小的图向中提取特征向量．选择一个patch，可以是任意的尺寸，但一般有一个固定的比例，如１／２，大小一般选择６４＊１２８pixel．

2. 梯度计算

使用ｈ=[-1, 0, 1]和v=[-1, 0, 1]^Ｔ两个ｋｅｒｎｅｌ来对图像进行卷积运算，分别得到水平和垂直方向上的梯度，在opencv中可以使用Sobel算子来计算．
```
// c++
imageMat *img = imread("");
img.convertTo(img, CV_32F, 1/255.0);
gyMat gx, gy;
Sobel(img, gx, cv2.CV_32F,1,0,1);
Sobel(img, gy, cv2.CV_32F,0,1,1);
gy=cv2.Sobel(img, cv2.CV_32F,1,0,ksize=1);
```
然后计算梯度的幅值ｇ和方向theta.
```
// c++
Mat mag, angle;
cartToPolar(gx, gy, mag, angle, 1);
```
方向为０－１８０°，标示无符号梯度，在实践中发现无方向梯度比有向梯度在进行检测时效果更好．

3. 在网格（８＊８）中计算梯度直方图

一个８＊８的图像有８＊８＊３＝１９２个像素值，　每个像素点有梯度幅度和方向两个值，三个channel取值mag最大的那个，所以每个cell有１２８(2*8＊8)个值
．对这１２８个值用９个ｂｉｎ的直方图来表示，不仅得到更紧凑的表示，也可以提高鲁棒性，降低噪音的敏感性．

一个patch(64*128)按８＊８大小的cell进行分割，可以分割成１２８个网格．

为这个１２８个网格分别创建直方图．以０,20,40．．．160这些角度作为pin．角度等于这些ｐｉｎ值的点，对应的ｐｉｎ值加上ｍａｇ，　否则按照角度幅值比例放到相邻的ｐｉｎ上．

4. 块归一化

一般图片的梯度对于整张图片的光线会很敏感，直接对像素点做处理，并不能消除光线的影响，为了使ＨＯＧ与光线变换无关，需要对直方图做归一化．
一般在２＊２个cell的块上面做归一化，也就是４＊８＊８的直方图上做归一化，一个ｃｅｌｌ的特征向量长度时９，　块状归一化后得到的向量长度时４＊９＝３６．

5. 特征向量

为了计算整个ｐａｔｃｈ的特征向量，需要把长度为３６的向量合并成一个巨大的向量．大小为：
７＊１５＊３６＝３７８０维的向量

个人觉得知乎这篇文章说的非常清楚：**https://zhuanlan.zhihu.com/p/33059421**